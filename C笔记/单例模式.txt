DCLP(double check lock)
=======================
一种进程间互斥访问的优化。

###背景：
有一个临界区，且这个临界区**`只可以被访问一次`**。   
多线程竞争，怎么搞定？

#####方案1：（标志位）
	static int flag = 0;
	
	if (0 == flag){
		flag = 1;
		//临界区
	}
	
显然此法失效。对flag的判断和对flag的修改没有绑定，中间可以钻空子。

#####方案2：（加上互斥锁）
	mutex.lock()
		if (0 == flag){
			flag = 1;
			//临界区
		}
	mutex.unlock()

此法有效。但是效率低下。问题在于，大量线程在lock上阻塞，但是其实只要有一个人进入以后，只有的互斥工作都是不必要的。	

###解决
#####方案3：（DCLP）
	if(0 == flag){      //只增加了这一句
		mutex.lock()
			if (0 == flag){
				flag = 1;
				//临界区
			}
		mutex.unlock()
	}
	
结合了两者的优点，只在最初的竞争中使用互斥锁，一旦临界区被访问，后续的进程便可直接跳过最外层的if循环，实现较高的效率。

######方案4：pthread_once()
方案3听说在c＋＋下有问题，所以这个方案应该是比较好的方案。

###应用
单例模式，如全局配置文件可以写成一个这样的类，供所有线程读取。（不懂……）

