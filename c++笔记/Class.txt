Class
=====

`注意1：所有类中的内容都是申明，包括静态变量，都是申明。`
`注意2：必须在定义时，严格区分是否可以复制。`

[TOC]


为什么需要class ？(自己理解)
----------------------
1. 结构体是把一组数据封装在一起，而class是更高层次的封装，把对这组数据对应的操作也包含进去。
2. 相对于结构体，class增加了似有权限(private)，组织外部直接访问内部变量，只能通过接口。强化对外屏蔽细节的特性。

---

Private 和 Public
---------------------
私有的，就是只有自己空间内的方法才能访问。  
共有的，就是main可以直接调用的。  
**关键1：** 就算是对象本身，在主函数里面也不可以直接访问私有变量，只能通过接口！！  
**关键2：** 对于友元，是指，`仅在friend的空间内`可以对你的`所有成员`进行访问。也就是说，在main里面也是不能调用的，也必须通过friend的`接口`。

`Protected`：除了自己以外，还对该类的继承类可见。

---

class的精髓
----------
以一套数据为`核心`，以及对这套数据`操作`的一套函数，使整体实现对外接口，屏蔽内部实现细节。用组装起来的小零件去组合更大的零件。

---

构造函数
-------
**关键1：**与class同名，必须放在public下，不能为const。  
**关键2：**自动执行，且不可手动执行  
**关键3：**如果你不写，系统会给你自动写一个，一旦你写了任何一种，系统就不管你了。  
**关键4：**你写了也不一定管用，需要匹配函数参数（可以重载）、const对象只能初始化不能赋值。

####关于构造函数的重载
一个class可以同时提供多个版本的构造函数，`只要参数不同`。但是注意如果定义了含参的构造函数，系统就不会再提供默认的无参构造，如果此时以无参的方式定义对象就会报错。

####关于初始化列表类型的构造函数
建议所有构造函数都用初始化列表形式，因为这样可以给const类型的对象进行初始化。    
一般定义一个无参构造函数，一个有参函数。  
**注意：**如果有依赖关系，必须注意顺序。如果没有，那无所谓顺序。无论怎样都按照定义的顺序初始化是个好习惯～～

####什么时候会调用构造函数？
- 定义对象时初始化
- `生成临时对象。`如：class_name(init_value),  string("test")

####什么时候析构函数？
- 函数运行离开变量生存期。（大括号、函数）

**另外：**如果只定义了构造函数，而没有定义复制函数。那么当用`=`初始化class时，系统会自动调用构造函数进行初始化。如果想要禁用自动调用，只需在构造函数前面加上`explicit`要求调用此函数必须符合参数列表。（有啥用？）

---

方法的重载
--------
**关键1；**当同时有const版本和非const版本方法时，const会调用const版本，非const对象会调用非const版本。  

**关键2:**  非const的对象也可以调用const具有const属性的方法。（只有一个版本时）

----

this指针
-------
**关键1；**在类中的普通方法被调用时，会隐藏地传入this指针，指向本对象。此时函数类型与原来不同，因为多了一个参数。  

**关键2；**在方法内返回this指针的引用，可以产生连续去方法的功能。如：`p.set_id(12).print(cout).set_age(22).print(cout)`

---

static修饰符（加了以后的变量属于类，共用！）
-----------
功能1；类内可以用static声明`静态变量`, 需要在类再再定义一下，实质是全局变量。所有的对象都拥有一份对整个变量的引用。调用时，`需要加上class的作用域。`

功能2；静态方法，加了static的方法退化为普通的函数，在调用时不会隐含this指针，（再线程函数定义时，隐含this指针会导致函数指针类型不符，只能用static）

---


怎么取得类静态函数的地址？
---------------------
如：class Test   
`&Test::public_function` 固定用法，记住即可。这里也说明了整个类的public方法，地址都是一样的。  
范例：`void (Test::*func) (const string &, int) = &Test::setValue; ` 左边是函数指针，右边是方法的地址。  

注意：如果是static属性的方法，则函数指针和平时一样，也不需要在方法的地址前面加`&`（这也证明了static方法就是普通函数的想法），但是指名作用域还是必要的。   
范例：`void (*func) () = Test::draw;` （draw是static的public方法）

---

构造函数的拷贝重载
----------------------
A(const A &){}。  用于直接对另一对象的初始化。即：`class B(A)`  
**关键：**如果不手动定制，系统会自动生成一个，将对class内所有的变量按**`原值`**复制。     

但是对于`共享的资源`来说，把对外的`引用`原值复制会出现问题。（比如指针，原值复制过来以后新旧对象指向同一个地址，一个对象如果free该地址，则另一对象旧报错）（浅拷贝）  
**解决方案：**手动定制一个拷贝构造函数，`把共享的资源也复制一份，使新旧class完全脱离，不相关。` 指针的例子就是把指向的地址内容也复制一份，让新的class内的指针指向新的地址即可。（深拷贝）

----

关于赋值(复制)函数
---------------------
`class & operator= (const class & Other).`  用于同类对象间赋值。即：`class A = B;`   

**关键：**也会自动生成，类似与拷贝构造函数。但是区别在于：  
1. 拷贝构造函数只用于初始化，但赋值函数可以用于普通赋值，所以需要考虑变量原来就含有内容的情况。（比如开辟了一个堆空间，需要释放）  
2. 需要考虑一个很二的情况：自己对自己赋值。（if判断一下即可，小case）

**小法则？：**［构造函数copy版］［赋值函数］［析构函数］三个如果一个需要写，那么另两个也需要写。


#####什么时候会发生对象复制(赋值)？
1. 作为非引用形参传入函数（另外：拷贝重载函数必须用引用参数，否则生成形参必须先拷贝。）
2. 作为返回值传出函数。
3. 放入容器对象。**重要！！**    
备注：如何禁止对象被复制？  答，自己定义一个空的赋值函数，设为私有即可。
范例：  

		#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
	            TypeName(const TypeName&); \
	            void operator=(const TypeName&)


操作符重载
------------
对于class的普通操作符，需要手工定义。  
**本质：** 是把对class的操作转化成对普通变量的操作，调用系统提供的操作符。   所以，操作符重载函数的定义中，两个操作数中，`必须有一个是class`，否则就会直接调用系统提供的普通的操作符处理。
**关键：**在class中定义的操作符重载函数，左操作数必为**本对象**。

**Tips1：**1.  `=`、`+=`建议在class内。 2. `>>`、`<<`必须用友元（因为class可能在右边嘛）
**Tips2：**对于`++`，前++ 和 后++都有固定的定义方式。
    
    class_type &operator++(){        //++i
        ++data_;
        return *this;
    }
    
    class_type operator++(int){		//i++
        class_type tmp(*this);   //先存起来，再++，然后返回这个预留的老值
        ++data_;
        return tmp;
    }


关于inline
-----------
在类体中定义的成员函数的规模一般都很小，而系统调用函数的过程所花费的时间开销相对是比较大的。调用一个函数的时间开销远远大于小规模函数体中全部语句的执行时间。为了减少时间开销，`如果在类体中定义的成员函数中不包括循环等控制结构`，C++系统会自动将它们作为内置(inline)函数来处理。

如果成员函数不在类体内定义，而在类体外定义，系统并不把它默认为内置(inline )函数，调用这些成员函数的过程和调用一般函数的过程是相同的。如果想将这些成员函数指定为内置函数，应当用inline作显式声明。（必须写在头文件里）

**注意1；**与宏函数不同，inline在**`编译期`**进行代码扩展。`(原代码在连接前已经被销毁)`

