C++ tips
======

[TOC]

###1. 引用 reference
- 相当于取别名
- 可以减少函数传参时的开销
- 如果不需要改变该值，请在引用参数前加上`const`保护它。
- 注：编译中的`discards qualifiers`一般是const属性的变量传入了非const。
- 另外：对于const的方法函数，如果想要例外的变量，可在变量申明时加上`mutable`修饰。（理解不深入）

----

###2. 动态内存分配 memory

####new 
关键1: 自动计算需要分配的长度   
关键2: 分配空间后，执行某些构造工作。（如，在空间头部记录空间长度）   
**用法：**  `new int`; `new int[10]`//申请10个; `new int(8)`;//初始化8
**重要：** 只能调用`无参`初始化函数！！

####delet
关键： 释放内存前，执行某些销毁工作。
**用法：**  `delete pointer` ;  `delete[] pointer`; //释放一片内存

######注意：C++的内存不可以任意直接拷贝（c语言可以）。拷贝无法生成合法的变量,尤其是对于标准库类型。

----

###3. 迭代器 iterator
**关键1：**用法类似指针，指向容器内的对象。其实就是专门用来`遍历`的，会自动抽象掉底层的数据结构，让你用一个统一的方法遍历整个容器。比如map会帮你自动对树中序遍历，对key降序。   
**关键2：**但**`不是`**指针！！it是一个对象，它不可以直接作为地址使用，如果需要当地址用，请`&*it`.  
**关键3；**容器中删除元素时，迭代器仍指向原地址，所以需要用删除函数得返回值更新。`（这条理解不够～）`

---

###4. 如何使用c库 ？
`#include <cstdio>`

---

###5. 关于重载 overload

重载就是可以重命名函数，以不同的形参列表区分。  

* 为什么能重载？  
	c++用`函数名＋形参列表`作为signature，而c只用函数名，所以c不能重载  
* 另外  
	c++编译的时候生成一张符号表(symbol table)，对形参列表进行缩写.(name mangling)

**重要！！** 对于操作符得重载，参数列表中必须有一个是class，否则系统不认。

---

###6. 语义 semantic （高大上，不懂，先记着）
- const：常量语义、保护语义
- 非const：修改语义
- pass-by-value：复制语义
- A(int a)类型构造函数： 转化语义

---
###7. RAII技术 (Resource Acquirement Is Initialization)
把`资源的获取`放在`构造函数`里面，`资源的释放`放在`析构函数`里面。这样可以保证在意外跳转函数时，不会跳过资源释放的语句。

例子：    
智能指针(`shared_ptr`)。把new操作放在构造函数里面，把delet放在析构函数里面。只要程序运行出了智能指针的生存周期，析构函数就会自动启动释放内存。安全无比。

---

###8, 临时变量的生存期
编译器的规定，临时变量不可以进行修改。所以临时变量不可以用修改语义传入函数，必须作为`const引用`形参。

###9. c++中的强制类型转换
`static_cast<target_type>`  和c语言版本的区别不明。

###10. 关于class类型形参
class类型的形参，允许调用初始化函数。比如如果该class可以用一个int初始化，那么把这个int传入形参是合法的。

###11. 基于对象和面向对象
1. 面向对象和基于对象编程的本质区别在于，基于对象将面向对象中由用户去继承实现的虚函数，改为回调函数，用户只需要向类中注册回调函数即可。
2. 面向对象主要是继承，基于对象主要是对象得组合。


###12. C++11的使用
编译时加入：`-std=c++0x`





