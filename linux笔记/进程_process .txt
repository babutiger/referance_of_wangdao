#进程

##进程标识号（ID）
1. 类型：unsigned int
2. 获取函数： `getpid()`获取进程id。 `getppid()`获取父进程id。

##子进程的创建

###1. system()函数
直接调用shell命令，以子进程运行。例如：system("clear")

###2. execl()函数
与system的区别是：执行该语句后，新进程完全替代当前进程（老的直接消失）

###*重要！*3. fork()函数 
完全复制父进程，产生一份一模一样的副本（包括堆栈、变量情况、执行位置）。唯一的不同就是父亲在fork（）返回子进程的id号，子进程返回0。 这样产生一个分支。

**注意：**fork 采用了一种“写时复制”(copy on write)的技术。在传 统的 UNIX 的进程模型中,fork 进程是把整个进程的项复制 一份,开销巨大。COW 就是在以前的基础上,子进程仅仅 复制父进程的页表,然后设为只读,任何一方试图修改项, 就将该项单独复制一份。

##杀进程
###发信号
`kill(pid_t pid, int sig)`  ----   sig为9时杀进程， 可`man 2 signal`查询
`pkill a.out`   ---    按照名字杀进程？？（不了解）
  
###信号手动处理
`signal()` －－ 信号注册函数，注册以后，当进程收到注册得信号，就会调用你写好得函数，而不是用系统默认处理。（比如子进程退出时会给父进程发SIGCHLD信号，可在父进程注册这个信号手动处理。）  
注意：探测返回值，防御式编程。   

###关于待处理信号
信号处理函数在处理当前信号时，新来的信号会被存入一个`待处理信号`的缓冲bitmap中，不是队列!!。（只能置为1）所以再有同样的信号来时，会被丢弃（称为`信号丢失`）。所以，当待处理信号中某位非0时，我们只能得出这个信号收到了`大于1次`的结论，而不知道具体收到了多少次。(bitmap中，一位代表一种类型的信号)


##进程资源的回收
进程资源一般由父进程回首，调用wait()函数等待子进程退出（阻塞式等待），以免出现僵尸进程。（子进程退出后，需要由父进程回收资源）
wait()函数随机地等待一个已经退出的子进程，当多个子进程同时退出时，需要循环。    
注意：如果没有任何**需要回收的**子进程，那么执行wait时，会立刻返回-1，同时errno为ECHLD。
waitpid()阻塞式等待，但是如果没有未回首的子进程，则立即返回。

	void sig_handle(int num)
	{
	   while(waitpid(-1, NULL, WNOHANG) > 0) ;  //因为信号缓冲队列只能保存一个同类信
                                                号，所以，如果一次性来了很多信号，我们
                                                就无法判断到底同时来了几个。于是我们需
                                                要用循环来回收所有的子进程。
        //-1代表等待任意进程号的子进程，null代表不接收stat_val(子进程退出状态)
	}
WIFEXITED(stat_val) 如果子进程正常结束，它就取一个非0值。 
WEXITSTATUS(stat_val) 如果WIFEXITED非零，它返回子进程的退出码 
options用于改变waitpid的行为，其中最常用的是WNOHANG，它表示无论子进程是否退出都将立即返回，不会将调用者的执行挂起。
	
##进程间通信的方式
- pipe（1. 无名。 2. 命名）
- socket（1. socketpair。2. 普通socket）


###exit与_exit的区别：
- exit会清空IO缓冲区，后者不会
- exit会处理通过atexit注册的函数
